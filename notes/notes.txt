尽量使用while 替代 for()

>>>0 作用: 无符号右移   相当于 逻辑右移
1.所有非数值转换成0
2.所有大于等于 0 数取整数部分

>>>1
1.非数值转为 0
2.正数时, 相当于 val/2 然后取整数部分
3.负数时, 转为很大的正数


x = 101101
x逻辑右移2位：001011
x算术右移2位：111011


以下三条语句的效率是: x = x + 1 <  x += 1  < x++

call 在大多数情况下比 apply性能好

var _has = {}.hasOwnProperty;
if(_has.call(obj, 'xxx')) //查看某个对象上是否有xxx属性

跳过了 _.findIndex和 _.findLastIndex 
******************看到_.first  方法  2015年10月25日00:44:25

$.type()  jquery 获取数据类型

/============
function(a){}.length   // 1
function(a, b){}.length   // 2
note: 函数的 length 得到的是形参个数
arguments.length   得到实参个数

跳过了 _.intersection

*****************_.pull 方法 2015年10月26日00:19:39

 
*****************_.remove 2015年10月28日00:04:07


*****************_.takeWhile 2015年10月29日00:06:05

*****************_.where 2015年10月31日22:18:45

只有函数被调用时,arguments对象才会被创建,未调用时其值为 null
函数 arguments 保存实参

在一个函数调用另一个函数时,被调用的函数会自动生成一个caller属性,指向调用它的函数对象.
如果该函数当前未被调用,或并非被其他函数调用,则caller为null
function testCaller() {
	var caller = testCaller.caller;
	alert(caller);
}
function aCaller() {
	testCaller();
}
aCaller();
弹窗会弹出 aCaller()函数的源码

当函数被调用时,它的arguments.callee对象就会指向自身,也就是一个对自己的引用. (多用于函数递归)
因为arguments是在函数调用时才有效,因此函数未调用时, arguments.callee为null

/=======================================

window.location 属性:
hash : #号开始的url
host : 主机名和当前url的端口号
hostname :主机名
href: 完整的url
pathname: 当前url的路径部分, / 斜杠部分
port: 端口号
protocol: url协议
search: ?号开始的url

js正则函数详细使用 没理清
页面宽度, div宽度等获取 浏览器差异没理清

=======================================/




*****************_.isArguments 2015年11月02日23:23:16
*****************_.add 2015年11月6日00:08:12

vue.js 笔记

实例属性: http://cn.vuejs.org/api/instance-properties.html
实例方法: http://cn.vuejs.org/api/instance-methods.html
全局api: http://cn.vuejs.org/api/global-api.html
组件选项: http://cn.vuejs.org/api/options.html

注意: 以 _ 或 $ 开头的属性将不会被代理在 Vue 实例上



//===============================
需要买的东西列单:
办公室面纸

//============================


vue.js 看到条件渲染  2015年11月6日23:36:56

vue 指令只封装 DOM 操作，而组件代表一个自给自足的独立单元


vue.js 看到过渡  2015年11月8日22:34:47

//=================================
ES5中新增了写数组方法，如下：
forEach (js v1.6)
map (js v1.6)
filter (js v1.6)
some (js v1.6)
every (js v1.6)
indexOf (js v1.6)
lastIndexOf (js v1.6)
reduce (js v1.8)
reduceRight (js v1.8)

url: http://www.zhangxinxu.com/wordpress/2013/04/es5新增数组方法/


看到vue-test4.html结束
vue.js 看到过渡  2015年11月15日23:49:47

有很多函数式库：underscore.js， lodash，Fantasy Land, Functional.js, Bilby.js, fn.js, Wu.js, Lazy.js, Bacon.js, sloth.js, stream.js, Sugar, Folktale, RxJs 

多种javascript变成方式:
命令式编程: 是建立在直接操作和检查程序状态之上.
面向原型的面向对象编程: 利用现有的对象作为原型来生成特定的实例
元编程: 编写代码叫做编程,当你的代码改变了某些代码被解释的方式. call apply时

原生对象({}) / 构造器 (构造函数)
每个对象都有__proto__属性 
原生对象/构造函数实例化的对象

prototype是函数的内置属性，__proto__是对象的内置属性
(方法这个特殊的对象，除了和其他对象一样有__proto__属性之外，
还有自己特有的属性——原型属性（prototype）)

在这里对"prototype"和"proto"进行简单的介绍：
对于所有的对象，都有proto属性，这个属性对应该对象的原型
对于函数对象，除了proto属性之外，还有prototype属性，
当一个函数被用作 构造函数 来创建实例时，
该函数的prototype属性值将被作为原型赋值给所有对象实例
（也就是设置实例的proto属性）,即实例的proto属性指向 构造函数的原型对象


所有的对象都有"proto"属性，该属性对应该对象的原型
所有的函数对象都有"prototype"属性，并且指向该函数对象的原型对象
该属性的值会被赋值给该函数创建的对象的"proto"属性
所有的原型对象都有"constructor"属性，该属性对应创建所有指向该原型的实例的构造函数
函数对象和原型对象通过"prototype"和"constructor"属性进行相互关联



	var Person = function(){};
	var p = new Person();
	new的过程拆分成以下三步：
	(1) var p={}; 也就是说，初始化一个对象p
	(2) p.__proto__ = Person.prototype;
	(3) Person.call(p); 也就是说构造p，也可以称之为初始化p



//===========   vue-test8.html 2015年11月17日00:08:26

//===========   vue-test9.html 2015年11月17日22:47:35

shift() 通常比 pop() 慢得多

slice()对象array中的某一段做浅复制

============= javascript 精粹 81 2015年11月22日23:22:44

闭包: 是一个函数,捕获作用域内的外部绑定。

函数式编程: "使用函数,而不是值"


//=========== javascript模式 P19 2015年11月26日23:20:51
